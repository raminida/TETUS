<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="ko" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2025 í…Œì¹œ ì˜¤í”ˆ ëŒ€ì‹œë³´ë“œ</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&family=Poppins:wght@600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #121212;
            --surface: #1E1E1E;
            --primary: #4CAF50;
            --primary-variant: #81C784;
            --text: #E0E0E0;
            --text-sec: #A0A0A0;
            --gold: #FFD700;
            --border: #333;
            --shadow: rgba(0, 0, 0, 0.5);
        }
        [data-theme="light"] {
            --bg: #F0F4F8;
            --surface: #FFF;
            --primary: #1A3C34;
            --primary-variant: #2A6B5B;
            --text: #1F2937;
            --text-sec: #6B7280;
            --border: #E5E7EB;
            --shadow: rgba(0, 0, 0, 0.1);
        }
        body {
            font-family: 'Noto Sans KR', sans-serif;
            background: var(--bg);
            color: var(--text);
            margin: 0;
            padding: 20px;
        }
        .container {
            max-width: 960px;
            margin: auto;
        }
        h1 {
            font-family: 'Poppins', sans-serif;
            font-size: 2.8rem;
            text-align: center;
            color: transparent;
            background: linear-gradient(135deg, var(--primary), var(--primary-variant));
            -webkit-background-clip: text;
            background-clip: text;
            padding: 20px 0;
            margin-bottom: 3rem;
        }
        .section {
            background: var(--surface);
            padding: 30px;
            border-radius: 16px;
            box-shadow: 0 10px 30px var(--shadow);
            margin-bottom: 3rem;
            border: 1px solid var(--border);
        }
        h2 {
            font-family: 'Poppins', sans-serif;
            font-size: 2.2rem;
            color: var(--primary);
            margin-bottom: 20px;
            border-bottom: 2px solid var(--border);
        }
        .charts-container {
            display: grid;
            gap: 40px;
        }
        .chart-control {
            margin-bottom: 20px;
            text-align: center;
        }
        .chart-control label {
            font-weight: 700;
            margin-right: 10px;
        }
        .chart-control select {
            padding: 8px;
            border-radius: 6px;
            border: 1px solid var(--border);
            background: var(--surface);
            color: var(--text);
            width: 200px;
        }
        .chart-control button {
            padding: 8px 16px;
            border-radius: 6px;
            border: 1px solid var(--border);
            background: linear-gradient(135deg, var(--primary), var--primary-variant);
            color: #FFF;
            cursor: pointer;
        }
        [data-theme="dark"] .chart-control button {
            color: var(--bg);
        }
        .awards-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
        }
        .award-card {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 20px;
            text-align: center;
        }
        [data-theme="light"] .award-card {
            background: #F9FAFB;
        }
        .award-icon {
            font-size: 3rem;
            margin-bottom: 10px;
            color: var(--gold);
        }
        .award-title {
            font-family: 'Poppins', sans-serif;
            font-size: 1.3rem;
            color: var(--primary-variant);
            margin-bottom: 5px;
        }
        .award-winner {
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--text);
        }
        .award-value {
            font-size: 0.9rem;
            color: var(--text-sec);
        }
        .award-runner-up {
            font-size: 0.9rem;
            color: var(--text-sec);
            margin-top: 5px;
        }
        .btn {
            display: inline-block;
            padding: 12px 28px;
            margin: 10px;
            background: linear-gradient(135deg, var(--primary), var(--primary-variant));
            color: #FFF;
            text-decoration: none;
            border-radius: 8px;
            font-weight: 700;
        }
        [data-theme="dark"] .btn {
            color: var(--bg);
        }
        .theme-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--text);
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, #333, #111);
            color: #fff;
            padding: 12px 25px;
            border-radius: 50px;
            box-shadow: 0 5px 15px var(--shadow);
            opacity: 0;
            transition: opacity 0.4s;
            font-weight: 700;
        }
        [data-theme="light"] .toast {
            background: linear-gradient(135deg, #f9f9f9, #f1f1f1);
            color: #333;
        }
        .toast.show {
            opacity: 1;
        }
        @media (max-width: 640px) {
            body { padding: 10px; }
            h1 { font-size: 2.2rem; }
            h2 { font-size: 1.8rem; }
            .section { padding: 20px; }
            .awards-grid { grid-template-columns: 1fr; }
            #mmr-chart-container canvas { height: 30vh; min-height: 200px; max-height: 300px; padding: 5px; }
            #mmr-chart-container { padding: 0 5px; }
            .charts-container { gap: 20px; }
        }
        @media (max-width: 480px) {
            #mmr-chart-container canvas { height: 25vh; min-height: 180px; max-height: 250px; }
        }
        #mmr-chart-container {
            position: relative;
            width: 100%;
            max-width: 100%;
            overflow-x: auto;
        }
        #mmr-chart-container canvas {
            height: 40vh;
            width: 100%;
            max-height: 400px;
        }
    </style>
</head>
<body>
    <button class="theme-toggle" id="theme-toggle">â˜€ï¸</button>
    <div class="container">
        <h1>2025 í…Œì¹œ ì˜¤í”ˆ ëŒ€ì‹œë³´ë“œ</h1>
        <div class="section">
            <h2>í†µê³„ ì°¨íŠ¸</h2>
            <div class="charts-container">
                <div id="mmr-chart-container">
                    <h3>MMR íˆìŠ¤í† ë¦¬</h3>
                    <div class="chart-control">
                        <label for="mmr-player-select">ì„ ìˆ˜ ì„ íƒ:</label>
                        <select id="mmr-player-select" multiple size="5"></select>
                        <button id="reset-mmr-chart">ì´ˆê¸°í™”</button>
                    </div>
                    <canvas id="mmr-chart"></canvas>
                </div>
            </div>
        </div>
        <div class="section">
            <h2>ğŸ† ì‹œì¦Œ ì–´ì›Œë“œ</h2>
            <div class="awards-grid"></div>
            <div style="text-align:center;margin-top:30px">
                <a href="index.html" class="btn">ë©”ì¸ìœ¼ë¡œ ëŒì•„ê°€ê¸°</a>
            </div>
        </div>
    </div>
    <div id="toast" class="toast"></div>

    <script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
            return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
            if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
                try {
                    var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                    var firstSheetName = workbook.SheetNames[0];
                    var worksheet = workbook.Sheets[firstSheetName];
                    var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                    var filteredData = jsonData.filter(row => row.some(filledCell));
                    var headerRowIndex = filteredData.findIndex((row, index) =>
                        row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                    );
                    if (headerRowIndex === -1 || headerRowIndex > 25) {
                        headerRowIndex = 0;
                    }
                    var csv = XLSX.utils.sheet_to_csv(XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)), { header: 1 });
                    return csv;
                } catch (e) {
                    console.error("XLSX íŒŒì‹± ì˜¤ë¥˜:", e);
                    showToast(`XLSX íŒŒì‹± ì‹¤íŒ¨: ${e.message || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜'}`);
                    return "";
                }
            }
            return gk_fileData[filename] || "";
        }

        let mmrChart, allPlayersData = [], fullMmrHistory = [], matchesData = [], awardsData = {};

        const femalePlayersList = ["ë‚¨ì •ì£¼", "ê¹€ìœ í•˜", "ì„±ì˜ˆì§„", "í•œí˜œë ¹", "ì¡°ì§€ì˜", "ì´ì€ì§€", "ê³ ê²½ë¦¬", "ê¹€ë‚˜ê²½", "ê¹€ì§€ì›", "ì´ì§€í™”", "ì •ì—°í™”", "ì°¨ê²½ë ¨", "í•œì •ì•„", "ìœ ì‹œì—°", "ê¹€ìœ ë¯¸", "ì‹ í˜„ì •", "ì´ì˜ˆì€", "ì´ì„ ë¯¸", "ë°•ì„ ìˆ™", "ë°•ì•„ë¦„", "ì´ì•„ë¦„", "ì„œìœ ë‚˜", "í—ˆì„ ì˜", "ì†¡ì€ì£¼", "ìœ¡í•˜ë‚˜", "ì´ê°€ì˜", "ì´ìœ ë¹ˆ", "ì •í•´ì˜", "ì¡°ìˆ˜í¬", "ì¡°ì•„í˜„", "ìµœì£¼ì—°", "í™©ìˆ˜ì§„"];

        const normalizePlayerName = name => name ? name.replace(/[@.*]+/g, '').trim().toLowerCase() : '';
        const totalGames = player => parseInt(player.wins || 0) + parseInt(player.losses || 0);

        const isMixedTeam = (p1, p2, data) => {
            const player1 = data.find(p => normalizePlayerName(p.name) === normalizePlayerName(p1));
            const player2 = data.find(p => normalizePlayerName(p.name) === normalizePlayerName(p2));
            return player1 && player2 && ((player1.isFemale && !player2.isFemale) || (!player1.isFemale && player2.isFemale));
        };

        const isMaleTeam = (p1, p2, data) => {
            const player1 = data.find(p => normalizePlayerName(p.name) === normalizePlayerName(p1));
            const player2 = data.find(p => normalizePlayerName(p.name) === normalizePlayerName(p2));
            return player1 && player2 && !player1.isFemale && !player2.isFemale;
        };

        const calculateMMRChange = (winner, loser, match, data) => {
            let multiplier = 1.0;
            const winnerIsMixed = isMixedTeam(match.winnerPlayer1, match.winnerPlayer2, data);
            const loserIsMixed = isMixedTeam(match.loserPlayer1, match.loserPlayer2, data);
            const winnerIsMale = isMaleTeam(match.winnerPlayer1, match.winnerPlayer2, data);
            const loserIsMale = isMaleTeam(match.loserPlayer1, match.loserPlayer2, data);
            if (winnerIsMixed && loserIsMale) multiplier = 2.0;
            else if (winnerIsMale && loserIsMixed) multiplier = 0.5;
            const change = Math.round(25 * multiplier);
            console.log(`MMR ë³€ê²½ ê³„ì‚°: ${winner} vs ${loser}, í˜¼ì„±: ${winnerIsMixed}/${loserIsMixed}, ë©€í‹°í”Œë¼ì´ì–´: ${multiplier}, ë³€ê²½: ${change}`);
            return change;
        };

        const debugLog = (player, award, score, ...metrics) => {
            console.log(`ë””ë²„ê¹… [${player.name}] - ${award}: ${score},`, ...metrics);
        };

        const loadFromCacheOrDefault = (key, defaultValue) => {
            try {
                const cached = localStorage.getItem(key);
                if (cached && cached !== '[]' && cached !== '{}') {
                    const { data, timestamp } = JSON.parse(cached);
                    const cacheAge = (Date.now() - timestamp) / (1000 * 60 * 60);
                    if (cacheAge < 24) {
                        console.log(`${key} ìºì‹œ ë¡œë“œ, ë‚˜ì´: ${cacheAge.toFixed(2)}ì‹œê°„`);
                        return data;
                    } else {
                        console.log(`${key} ìºì‹œ ì˜¤ë˜ë¨, ì‚­ì œ`);
                        localStorage.removeItem(key);
                    }
                }
            } catch (e) {
                console.error(`ìºì‹œ íŒŒì‹± ì˜¤ë¥˜ (${key}):`, e);
            }
            return defaultValue;
        };

        const setupMmrPlayerSelector = () => {
            const select = document.getElementById('mmr-player-select');
            if (!select) {
                console.error("MMR ì„ ìˆ˜ ì„ íƒ ì…€ë ‰í„° ì—†ìŒ");
                showToast("MMR ì„ ìˆ˜ ì„ íƒ ì˜¤ë¥˜!");
                return;
            }
            select.innerHTML = allPlayersData.map(p => `<option value="${p.name}">${p.name}${p.isFemale ? '*' : ''}</option>`).join('');
            select.addEventListener('change', e => {
                const selectedPlayers = Array.from(e.target.selectedOptions).map(opt => opt.value);
                console.log("ì„ íƒëœ í”Œë ˆì´ì–´:", selectedPlayers);
                renderMmrChart(fullMmrHistory, selectedPlayers);
            });

            const resetButton = document.getElementById('reset-mmr-chart');
            if (!resetButton) {
                console.error("MMR ì°¨íŠ¸ ì´ˆê¸°í™” ë²„íŠ¼ ì—†ìŒ");
                showToast("MMR ì°¨íŠ¸ ì´ˆê¸°í™” ë²„íŠ¼ ì˜¤ë¥˜!");
                return;
            }
            resetButton.addEventListener('click', () => {
                select.selectedIndex = -1;
                if (mmrChart) {
                    mmrChart.destroy();
                    mmrChart = null;
                }
                const ctx = document.getElementById('mmr-chart')?.getContext('2d');
                if (ctx) ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                console.log("MMR ì°¨íŠ¸ ì´ˆê¸°í™” ì™„ë£Œ");
            });
        };

        const renderMmrChart = (history, selectedPlayers) => {
            const ctx = document.getElementById('mmr-chart')?.getContext('2d');
            if (!ctx) {
                console.error("MMR ì°¨íŠ¸ ìº”ë²„ìŠ¤ ì—†ìŒ");
                showToast("ê·¸ë˜í”„ ì˜¤ë¥˜!");
                return;
            }
            if (!selectedPlayers.length) {
                console.error("ì„ íƒëœ í”Œë ˆì´ì–´ ì—†ìŒ:", selectedPlayers);
                showToast("í”Œë ˆì´ì–´ ì„ íƒ í•„ìš”!");
                return;
            }

            const endDate = new Date().getTime();
            const startDate = endDate - 60 * 24 * 60 * 60 * 1000; // 60ì¼ ì „
            const SEVEN_DAYS_MS = 7 * 24 * 60 * 60 * 1000;

            let intervalDates = [];
            for (let t = startDate; t <= endDate; t += SEVEN_DAYS_MS) {
                intervalDates.push(t);
            }

            let displayHistory = history
                .filter(h => {
                    const createdAt = new Date(h.createdAt).getTime();
                    return createdAt >= startDate && createdAt <= endDate;
                })
                .sort((a, b) => new Date(a.createdAt) - new Date(b.createdAt));

            displayHistory = intervalDates.map(targetDate => {
                const nearestSnapshot = displayHistory.reduce((prev, curr) => {
                    const currTime = new Date(curr.createdAt).getTime();
                    const prevTime = prev ? new Date(prev.createdAt).getTime() : Infinity;
                    return Math.abs(currTime - targetDate) < Math.abs(prevTime - targetDate) ? curr : prev;
                }, null);
                if (!nearestSnapshot) {
                    const snapshot = { createdAt: new Date(targetDate).toISOString() };
                    allPlayersData.forEach(p => {
                        const cleanName = normalizePlayerName(p.name).replace(/\./g, '_');
                        snapshot[cleanName] = p.mmr || 1500;
                    });
                    console.log(`ìŠ¤ëƒ…ìƒ· ìƒì„±: ${snapshot.createdAt}, ê¸°ë³¸ MMR 1500`);
                    return snapshot;
                }
                return { ...nearestSnapshot, createdAt: new Date(targetDate).toISOString() };
            });

            displayHistory = displayHistory.reduce((acc, curr) => {
                const dateStr = new Date(curr.createdAt).toLocaleDateString('ko-KR');
                const existing = acc.find(h => new Date(h.createdAt).toLocaleDateString('ko-KR') === dateStr);
                if (!existing) {
                    acc.push(curr);
                } else if (new Date(curr.createdAt) > new Date(existing.createdAt)) {
                    acc[acc.indexOf(existing)] = curr;
                }
                return acc;
            }, []);

            displayHistory = displayHistory.map(h => {
                const snapshot = { ...h };
                allPlayersData.forEach(p => {
                    const cleanName = normalizePlayerName(p.name).replace(/\./g, '_');
                    if (snapshot[cleanName] === undefined) {
                        snapshot[cleanName] = p.mmr || 1500;
                        console.log(`MMR ë³´ì™„: ${p.name} in ${snapshot.createdAt}, ê°’: ${snapshot[cleanName]}`);
                    }
                });
                return snapshot;
            });

            console.log("í‘œì‹œí•  íˆìŠ¤í† ë¦¬:", displayHistory.length, "ìŠ¤ëƒ…ìƒ·");

            const colors = ['#FF0000', '#0000FF', '#FFFF00', '#008000', '#800080', '#FF00FF', '#00FFFF', '#FFA500', '#FFC0CB', '#A52A2A'];
            const datasets = selectedPlayers.map((name, i) => {
                const cleanName = normalizePlayerName(name).replace(/\./g, '_');
                return {
                    label: name,
                    data: displayHistory.map(h => {
                        const mmr = h[cleanName] ?? 1500;
                        if (mmr === null || isNaN(mmr)) {
                            console.warn(`ìœ íš¨í•˜ì§€ ì•Šì€ MMR: ${name}, ê°’: ${mmr}`);
                            return 1500;
                        }
                        return mmr;
                    }),
                    borderColor: colors[i % colors.length],
                    fill: false,
                    tension: 0.3,
                    pointRadius: 5,
                    pointHoverRadius: 8,
                    borderWidth: 3
                };
            });

            const labels = displayHistory.map(h => new Date(h.createdAt).toLocaleDateString('ko-KR'));

            const mmrValues = datasets.flatMap(ds => ds.data).filter(v => v !== null);
            const minMMR = mmrValues.length ? Math.floor(Math.min(...mmrValues) / 50) * 50 - 50 : 1480;
            const maxMMR = mmrValues.length ? Math.ceil(Math.max(...mmrValues) / 50) * 50 + 50 : 1800;

            if (mmrChart) {
                try { mmrChart.destroy(); } catch (e) { console.error("Chart.destroy ì‹¤íŒ¨:", e); }
            }
            try {
                mmrChart = new Chart(ctx, {
                    type: 'line',
                    data: { labels, datasets },
                    options: {
                        scales: {
                            x: { ticks: { color: 'var(--text-sec)', font: { size: 12 }, maxRotation: 45, minRotation: 45 }, grid: { color: 'var(--border)' } },
                            y: { ticks: { color: 'var(--text-sec)', font: { size: 12 }, stepSize: 50 }, grid: { color: 'var(--border)' }, min: minMMR, max: maxMMR, title: { display: true, text: 'MMR', color: 'var(--text)', font: { size: 14 } } }
                        },
                        plugins: {
                            legend: { labels: { color: 'var(--text)', font: { size: 14 }, boxWidth: 20, boxHeight: 2, padding: 15 }, position: 'top' },
                            tooltip: { enabled: true, backgroundColor: 'rgba(0,0,0,0.8)', titleColor: '#fff', bodyColor: '#fff', padding: 10, cornerRadius: 6, callbacks: { label: c => `${c.dataset.label}: ${c.parsed.y}` } }
                        },
                        interaction: { mode: 'nearest', intersect: false },
                        maintainAspectRatio: false,
                        responsive: true
                    }
                });
            } catch (e) {
                console.error("Chart ì´ˆê¸°í™” ì‹¤íŒ¨:", e);
                showToast("ê·¸ë˜í”„ ë Œë”ë§ ì‹¤íŒ¨!");
            }
        };

        const showToast = (msg, duration = 3000) => {
            console.log(`showToast í˜¸ì¶œ: ${msg}, DOM ë¡œë“œ ì—¬ë¶€: ${document.readyState}`);
            const toast = document.getElementById('toast');
            if (!toast) {
                console.error('Toast ìš”ì†Œ ì—†ìŒ');
                return;
            }
            if (toast.classList.contains('show')) return;
            toast.textContent = msg;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), duration);
        };

        const applyTheme = theme => {
            document.documentElement.setAttribute('data-theme', theme);
            document.getElementById('theme-toggle').textContent = theme === 'dark' ? 'â˜€ï¸' : 'ğŸŒ™';
            localStorage.setItem('theme', theme);
            if (mmrChart && document.getElementById('mmr-player-select')?.selectedOptions) {
                const selectedPlayers = Array.from(document.getElementById('mmr-player-select').selectedOptions).map(opt => opt.value);
                renderMmrChart(fullMmrHistory, selectedPlayers);
            }
        };

        const loadDashboard = async () => {
            try {
                console.log("loadDashboard ì‹œì‘");

                // localStorageì—ì„œ ë°ì´í„° ë¡œë“œ
                const savedRounds = new Map(JSON.parse(localStorage.getItem('savedRounds') || '[]'));
                allPlayersData = JSON.parse(localStorage.getItem('rankingData') || '[]');
                if (!allPlayersData.length) {
                    console.warn("ë­í‚¹ ë°ì´í„° ì—†ìŒ, ê¸°ë³¸ ì„ ìˆ˜ë¡œ ì´ˆê¸°í™”");
                    allPlayersData = [{ name: "ê¸°ë³¸ ì„ ìˆ˜", mmr: 1500, wins: 0, losses: 0, gameDiff: 0, totalSets: 0, isFemale: false, championships: 0, dominantWins: 0, dominantLosses: 0, closeSets: 0 }];
                }
                allPlayersData = allPlayersData.map(p => ({
                    ...p,
                    gender: femalePlayersList.includes(normalizePlayerName(p.name)) || p.isFemale ? 'F' : 'M'
                }));
                console.log("ë­í‚¹ ë°ì´í„°:", allPlayersData.length, "ëª…");

                // MMR íˆìŠ¤í† ë¦¬ ìƒì„±
                fullMmrHistory = [];
                matchesData = [];
                const BASE_MMR = 1500;
                savedRounds.forEach((roundData, roundId) => {
                    if (!roundData.matches) return;
                    const timestamp = roundData.timestamp || new Date().toISOString();
                    const snapshot = { createdAt: timestamp };
                    allPlayersData.forEach(p => {
                        snapshot[normalizePlayerName(p.name).replace(/\./g, '_')] = p.mmr || BASE_MMR;
                    });

                    roundData.matches.forEach((match, index) => {
                        const p1 = match.player1.replace(/\*/g, '');
                        const p2 = match.player2.replace(/\*/g, '');
                        const p3 = match.player3.replace(/\*/g, '');
                        const p4 = match.player4.replace(/\*/g, '');
                        const score = match.score;
                        const isFourPoint = match.isFourPoint;

                        if (!p1 || !p2 || !p3 || !p4 || !/^\d+-\d+$/.test(score)) return;

                        const [score1, score2] = score.split('-').map(Number);
                        const gameDiff = Math.abs(score1 - score2);
                        const winnerPlayer1 = score1 > score2 ? p1 : p3;
                        const winnerPlayer2 = score1 > score2 ? p2 : p4;
                        const loserPlayer1 = score1 > score2 ? p3 : p1;
                        const loserPlayer2 = score1 > score2 ? p4 : p2;

                        matchesData.push({
                            id: `${roundId}-${index}`,
                            player1: p1,
                            player2: p2,
                            winnerPlayer1,
                            winnerPlayer2,
                            loserPlayer1,
                            loserPlayer2,
                            gameDiff,
                            createdAt: timestamp
                        });

                        // MMR ê³„ì‚°
                        const team1MMR = ((allPlayersData.find(p => p.name === p1)?.mmr || BASE_MMR) + (allPlayersData.find(p => p.name === p2)?.mmr || BASE_MMR)) / 2;
                        const team2MMR = ((allPlayersData.find(p => p.name === p3)?.mmr || BASE_MMR) + (allPlayersData.find(p => p.name === p4)?.mmr || BASE_MMR)) / 2;
                        const mmrChange = calculateMMRChange(winnerPlayer1, loserPlayer1, { winnerPlayer1, winnerPlayer2, loserPlayer1, loserPlayer2 }, allPlayersData);

                        [p1, p2].forEach(p => {
                            const player = allPlayersData.find(pl => pl.name === p);
                            if (player) {
                                snapshot[normalizePlayerName(p).replace(/\./g, '_')] = (player.mmr || BASE_MMR) + (score1 > score2 ? mmrChange : -mmrChange);
                            }
                        });
                        [p3, p4].forEach(p => {
                            const player = allPlayersData.find(pl => pl.name === p);
                            if (player) {
                                snapshot[normalizePlayerName(p).replace(/\./g, '_')] = (player.mmr || BASE_MMR) + (score2 > score1 ? mmrChange : -mmrChange);
                            }
                        });
                    });

                    fullMmrHistory.push(snapshot);
                });

                localStorage.setItem('mmrHistoryCache', JSON.stringify({ data: fullMmrHistory, timestamp: Date.now() }));
                localStorage.setItem('matchesDataCache', JSON.stringify({ data: matchesData, timestamp: Date.now() }));
                console.log("MMR íˆìŠ¤í† ë¦¬:", fullMmrHistory.length, "ìŠ¤ëƒ…ìƒ·");
                console.log("ë§¤ì¹˜ ë°ì´í„°:", matchesData.length, "ê²½ê¸°");

                // ì–´ì›Œë“œ ê³„ì‚°
                const playedPlayers = allPlayersData.filter(p => totalGames(p) >= 0);
                if (playedPlayers.length) {
                    const getRank = (p, stat) => [...playedPlayers].sort((a, b) => (b[stat] || 0) - (a[stat] || 0)).findIndex(pl => pl.name === p.name) + 1;
                    const getPercentileScore = rank => playedPlayers.length <= 1 ? 100 : Math.pow((playedPlayers.length - rank) / (playedPlayers.length - 1), 0.7) * 100;

                    let mvpMalePlayer = null, maxMvpMaleScore = -Infinity, mvpMaleRunnerUp = null, secondMvpMaleScore = -Infinity;
                    let mvpFemalePlayer = null, maxMvpFemaleScore = -Infinity, mvpFemaleRunnerUp = null, secondMvpFemaleScore = -Infinity;
                    let mostImprovedPlayer = null, maxImprovedScore = -Infinity, improvedRunnerUp = null, secondImprovedScore = -Infinity;
                    let dominantForcePlayer = null, maxDominantForceScore = -Infinity, dominantForceRunnerUp = null, secondDominantForceScore = -Infinity;
                    let winKingPlayer = null, maxWinDiff = -Infinity, winKingRunnerUp = null, secondWinDiff = -Infinity;
                    let playerOfMonthPlayer = null, maxPlayerOfMonthScore = -Infinity, playerOfMonthRunnerUp = null, secondPlayerOfMonthScore = -Infinity;
                    let peakMmrPlayer = null, maxPeakMmr = -Infinity, peakMmrRunnerUp = null, secondPeakMmr = -Infinity;

                    const FOUR_WEEKS_MS = 4 * 7 * 24 * 60 * 60 * 1000;
                    const now = new Date().getTime();

                    playedPlayers.forEach(player => {
                        const totalGamesPlayed = totalGames(player);
                        const totalSets = parseInt(player.totalSets || totalGamesPlayed);
                        const gameCountBonus = Math.min(1.05, 1 + totalGamesPlayed * 0.002);

                        player.mmr = parseInt(player.mmr) || 1500;
                        player.wins = parseInt(player.wins) || 0;
                        player.losses = parseInt(player.losses) || 0;

                        const mmrRank = getRank(player, 'mmr');
                        const mmrScore = getPercentileScore(mmrRank) / 10;
                        player.winRate = totalGamesPlayed > 0 ? player.wins / totalGamesPlayed : 0;
                        const winRateRank = getRank(player, 'winRate');
                        const winRateScore = getPercentileScore(winRateRank) / 10;
                        player.normChampionships = parseInt(player.championships || 0);
                        const champRank = getRank(player, 'normChampionships');
                        const champScore = getPercentileScore(champRank) / 10;
                        player.dominantRate = parseFloat(player.dominantWins || 0);
                        const dominantRank = getRank(player, 'dominantRate');
                        const dominantRadarScore = getPercentileScore(dominantRank) / 10;
                        player.gameDiffRate = totalGamesPlayed > 0 ? (player.gameDiff || 0) / totalGamesPlayed : 0;
                        const gameDiffRank = getRank(player, 'gameDiffRate');
                        const gameDiffScore = getPercentileScore(gameDiffRank) / 10;

                        let mvpScore = (mmrScore + winRateScore + champScore + dominantRadarScore + 0.5 * gameDiffScore) / 4.5 * gameCountBonus;
                        mvpScore = mvpScore.toFixed(1);
                        if (player.gender === 'M') {
                            if (parseFloat(mvpScore) > maxMvpMaleScore) {
                                secondMvpMaleScore = maxMvpMaleScore; mvpMaleRunnerUp = mvpMalePlayer;
                                maxMvpMaleScore = parseFloat(mvpScore); mvpMalePlayer = { name: player.name, value: mvpScore };
                            } else if (parseFloat(mvpScore) > secondMvpMaleScore && parseFloat(mvpScore) < maxMvpMaleScore) {
                                secondMvpMaleScore = parseFloat(mvpScore); mvpMaleRunnerUp = { name: player.name, value: mvpScore };
                            }
                        } else if (player.gender === 'F') {
                            if (parseFloat(mvpScore) > maxMvpFemaleScore) {
                                secondMvpFemaleScore = maxMvpFemaleScore; mvpFemaleRunnerUp = mvpFemalePlayer;
                                maxMvpFemaleScore = parseFloat(mvpScore); mvpFemalePlayer = { name: player.name, value: mvpScore };
                            } else if (parseFloat(mvpScore) > secondMvpFemaleScore && parseFloat(mvpScore) < maxMvpFemaleScore) {
                                secondMvpFemaleScore = parseFloat(mvpScore); mvpFemaleRunnerUp = { name: player.name, value: mvpScore };
                            }
                        }

                        const playerHistory = fullMmrHistory
                            .map(h => h[normalizePlayerName(player.name).replace(/\./g, '_')])
                            .filter(mmr => mmr !== undefined);
                        console.log(`í”Œë ˆì´ì–´ ${player.name} íˆìŠ¤í† ë¦¬:`, playerHistory.length, "ë ˆì½”ë“œ", playerHistory.slice(0, 5));

                        const initialMMR = playerHistory.length > 0 ? playerHistory[0] : 1500;
                        player.mmrGrowthRate = initialMMR > 0 ? ((player.mmr - initialMMR) / initialMMR * 100) : 0;
                        const mmrGrowthRank = getRank(player, 'mmrGrowthRate');
                        const mmrGrowthScore = getPercentileScore(mmrGrowthRank) / 10;

                        const earlyGames = playerHistory.slice(0, 3);
                        const lateGames = playerHistory.slice(-3);
                        const earlyWins = earlyGames.filter((_, i) => i % 2 === 0 && earlyGames[i + 1] > earlyGames[i]).length;
                        const lateWins = lateGames.filter((_, i) => i % 2 === 0 && lateGames[i + 1] > earlyGames[i]).length;
                        const earlyLosses = earlyGames.filter((_, i) => i % 2 === 0 && earlyGames[i + 1] < earlyGames[i]).length;
                        const lateLosses = lateGames.filter((_, i) => i % 2 === 0 && lateGames[i + 1] < earlyGames[i]).length;
                        const earlyWinRate = (earlyWins + earlyLosses) > 0 ? earlyWins / (earlyWins + earlyLosses) : 0;
                        const lateWinRate = (lateWins + lateLosses) > 0 ? lateWins / (lateWins + lateLosses) : 0;
                        player.winRateImprovement = lateWinRate - earlyWinRate;
                        const winRateImproveRank = getRank(player, 'winRateImprovement');
                        const winRateImproveScore = getPercentileScore(winRateImproveRank) / 10;

                        let improvedScore = (mmrGrowthScore * 0.3 + winRateImproveScore * 0.3 + winRateImproveScore * 0.4) * gameCountBonus;
                        improvedScore = improvedScore.toFixed(1);
                        debugLog(player, 'ë°œì „ìƒ ì ìˆ˜', improvedScore, { mmrGrowthScore, winRateImproveScore });
                        if (parseFloat(improvedScore) > maxImprovedScore) {
                            secondImprovedScore = maxImprovedScore; improvedRunnerUp = mostImprovedPlayer;
                            maxImprovedScore = parseFloat(improvedScore); mostImprovedPlayer = { name: player.name, value: improvedScore };
                        } else if (parseFloat(improvedScore) > secondImprovedScore && parseFloat(improvedScore) < maxImprovedScore) {
                            secondImprovedScore = parseFloat(improvedScore); improvedRunnerUp = { name: player.name, value: improvedScore };
                        }

                        const dominantWins = parseInt(player.dominantWins || 0);
                        const dominantWinRate = totalGamesPlayed > 0 ? dominantWins / totalGamesPlayed * 100 : 0;
                        let dominantForceScore = (dominantWins * 0.6 + dominantWinRate * 0.4) * gameCountBonus;
                        debugLog(player, 'ì••ë„ì  í¬ìŠ¤ ì ìˆ˜', dominantForceScore.toFixed(2), { 'ì••ë„ ìŠ¹ë¦¬': dominantWins, 'ì••ë„ ìŠ¹ë¥ ': dominantWinRate.toFixed(2) });
                        if (totalGamesPlayed >= 1 && dominantWins >= 1) {
                            if (dominantForceScore > maxDominantForceScore) {
                                secondDominantForceScore = maxDominantForceScore; dominantForceRunnerUp = dominantForcePlayer;
                                maxDominantForceScore = dominantForceScore; dominantForcePlayer = { name: player.name, value: dominantForceScore.toFixed(2) };
                            } else if (dominantForceScore > secondDominantForceScore && dominantForceScore < maxDominantForceScore) {
                                secondDominantForceScore = dominantForceScore; dominantForceRunnerUp = { name: player.name, value: dominantForceScore.toFixed(2) };
                            }
                        }

                        const winDiff = player.wins - player.losses;
                        if (totalGamesPlayed >= 1) {
                            const adjustedWinDiff = winDiff * gameCountBonus;
                            if (adjustedWinDiff > maxWinDiff) {
                                secondWinDiff = maxWinDiff; winKingRunnerUp = winKingPlayer;
                                maxWinDiff = adjustedWinDiff; winKingPlayer = { name: player.name, value: adjustedWinDiff.toFixed(1) };
                            } else if (adjustedWinDiff > secondWinDiff && adjustedWinDiff < maxWinDiff) {
                                secondWinDiff = adjustedWinDiff; winKingRunnerUp = { name: player.name, value: adjustedWinDiff.toFixed(1) };
                            }
                        }

                        const recentMatches = matchesData.filter(match => (normalizePlayerName(match.player1) === normalizePlayerName(player.name) || normalizePlayerName(match.player2) === normalizePlayerName(player.name)) && (now - new Date(match.createdAt || now).getTime() <= FOUR_WEEKS_MS));
                        const recentWins = recentMatches.filter(match => normalizePlayerName(match.winnerPlayer1) === normalizePlayerName(player.name) || normalizePlayerName(match.winnerPlayer2) === normalizePlayerName(player.name)).length;
                        const recentWinRate = recentMatches.length > 0 ? recentWins / recentMatches.length : 0;
                        const recentGameDiff = recentMatches.reduce((sum, match) => (normalizePlayerName(match.winnerPlayer1) === normalizePlayerName(player.name) || normalizePlayerName(match.winnerPlayer2) === normalizePlayerName(player.name)) ? sum + parseFloat(match.gameDiff || 0) : sum - parseFloat(match.gameDiff || 0), 0);
                        const recentPlayerHistory = fullMmrHistory.filter(h => now - new Date(h.createdAt || now).getTime() <= FOUR_WEEKS_MS).map(h => h[normalizePlayerName(player.name).replace(/\./g, '_')]).filter(mmr => mmr !== undefined);
                        const mmrIncrease = recentPlayerHistory.length > 1 ? (recentPlayerHistory[recentPlayerHistory.length - 1] - recentPlayerHistory[0]) : 0;
                        let playerOfMonthScore = (recentWinRate * 50 + mmrIncrease * 0.5 + recentGameDiff * 2) * gameCountBonus;
                        debugLog(player, 'ì´ë‹¬ì˜ ì„ ìˆ˜ ì ìˆ˜', playerOfMonthScore.toFixed(2), { 'ìµœê·¼ ìŠ¹ë¥ ': recentWinRate.toFixed(2), 'MMR ìƒìŠ¹': mmrIncrease, 'ê²Œì„ ë“ì‹¤': recentGameDiff, 'ê²½ê¸° ìˆ˜': recentMatches.length });
                        if (totalGamesPlayed >= 1 && playerOfMonthScore > 0) {
                            if (playerOfMonthScore > maxPlayerOfMonthScore) {
                                secondPlayerOfMonthScore = maxPlayerOfMonthScore; playerOfMonthRunnerUp = playerOfMonthPlayer;
                                maxPlayerOfMonthScore = playerOfMonthScore; playerOfMonthPlayer = { name: player.name, value: playerOfMonthScore.toFixed(2) };
                            } else if (playerOfMonthScore > secondPlayerOfMonthScore && playerOfMonthScore < maxPlayerOfMonthScore) {
                                secondPlayerOfMonthScore = playerOfMonthScore; playerOfMonthRunnerUp = { name: player.name, value: playerOfMonthScore.toFixed(2) };
                            }
                        }

                        const peakMmr = playerHistory.length > 0 ? Math.max(...playerHistory) : player.mmr || 1500;
                        debugLog(player, 'ìµœê³ ì  MMR', peakMmr, { playerHistoryLength: playerHistory.length, fallbackMmr: player.mmr || 1500, historySample: playerHistory.slice(0, 5) });
                        if (totalGamesPlayed >= 1) {
                            if (peakMmr > maxPeakMmr) {
                                secondPeakMmr = maxPeakMmr; peakMmrRunnerUp = peakMmrPlayer;
                                maxPeakMmr = peakMmr; peakMmrPlayer = { name: player.name, value: peakMmr };
                            } else if (peakMmr > secondPeakMmr && peakMmr < maxPeakMmr) {
                                secondPeakMmr = peakMmr; peakMmrRunnerUp = { name: player.name, value: peakMmr };
                            }
                        }
                    });

                    awardsData = {
                        mvpMale: { winner: mvpMalePlayer || { name: '-', value: '-' }, runnerUp: mvpMaleRunnerUp || { name: '-', value: '-' } },
                        mvpFemale: { winner: mvpFemalePlayer || { name: '-', value: '-' }, runnerUp: mvpFemaleRunnerUp || { name: '-', value: '-' } },
                        mostImproved: { winner: mostImprovedPlayer || { name: '-', value: '-' }, runnerUp: improvedRunnerUp || { name: '-', value: '-' } },
                        dominantForce: { winner: dominantForcePlayer || { name: '-', value: '-' }, runnerUp: dominantForceRunnerUp || { name: '-', value: '-' } },
                        winKing: { winner: winKingPlayer || { name: '-', value: '-' }, runnerUp: winKingRunnerUp || { name: '-', value: '-' } },
                        playerOfMonth: { winner: playerOfMonthPlayer || { name: '-', value: '-' }, runnerUp: playerOfMonthRunnerUp || { name: '-', value: '-' } },
                        peakMmr: { winner: peakMmrPlayer || { name: '-', value: '-' }, runnerUp: peakMmrRunnerUp || { name: '-', value: '-' } }
                    };
                    localStorage.setItem('awardsCache', JSON.stringify({ data: awardsData, timestamp: Date.now() }));
                    console.log("ì–´ì›Œë“œ ë°ì´í„°:", Object.keys(awardsData).length, "ê°œ");

                    const awardDetails = {
                        mvpMale: { title: "ì‹œì¦Œ MVP (ë‚¨)", icon: "ğŸ‘‘" },
                        mvpFemale: { title: "ì‹œì¦Œ MVP (ì—¬)", icon: "ğŸ‘‘" },
                        mostImproved: { title: "ì‹œì¦Œ ë°œì „ìƒ", icon: "ğŸš€" },
                        dominantForce: { title: "ì‹œì¦Œ ì••ë„ì  í¬ìŠ¤", icon: "ğŸ’£" },
                        winKing: { title: "ì‹œì¦Œ ë‹¤ìŠ¹ì™•", icon: "ğŸ†" },
                        playerOfMonth: { title: "ì´ë‹¬ì˜ ì„ ìˆ˜ìƒ", icon: "ğŸŒŸ" },
                        peakMmr: { title: "ì‹œì¦Œ ìµœê³ ì ", icon: "ğŸŒŸ" }
                    };

                    const grid = document.querySelector('.awards-grid');
                    if (!grid) {
                        console.error("ì–´ì›Œë“œ ê·¸ë¦¬ë“œ ìš”ì†Œ ì—†ìŒ");
                        showToast("ì–´ì›Œë“œ ê·¸ë¦¬ë“œ ì˜¤ë¥˜!");
                        return;
                    }
                    grid.innerHTML = '';
                    for (const key in awardDetails) {
                        const awardInfo = awardDetails[key];
                        const data = awardsData[key] || { winner: { name: '-', value: '-' }, runnerUp: { name: '-', value: '-' } };
                        console.log(`ì–´ì›Œë“œ ë Œë”ë§: ${key}, ë°ì´í„°:`, data);
                        const winner = data.winner?.name || data.name || '-';
                        const winnerValue = data.winner?.value || data.value || '-';
                        const runnerUp = data.runnerUp?.name || '-';
                        const runnerUpValue = data.runnerUp?.value || data.value || '-';
                        const card = document.createElement('div');
                        card.className = 'award-card';
                        console.log(`award-card HTML ìƒì„±: ${key}`);
                        card.innerHTML = `
                            <div class="award-icon">${awardInfo.icon}</div>
                            <div class="award-title">${awardInfo.title}</div>
                            <div class="award-winner">${winner}${winner !== '-' ? (allPlayersData.find(p => p.name === winner)?.isFemale ? '*' : '') : ''}</div>
                            <div class="award-value">${key === 'dominantForce' ? 'ì••ë„ ì ìˆ˜' : key === 'winKing' ? 'ìŠ¹ì°¨' : key === 'playerOfMonth' ? 'ì›”ê°„ ì ìˆ˜' : key === 'mostImproved' ? 'ê°œì„  ì ìˆ˜' : key === 'mvpMale' || key === 'mvpFemale' ? 'MVP ì ìˆ˜' : key === 'peakMmr' ? 'ìµœê³  MMR' : 'ì ìˆ˜'}: ${winnerValue}</div>
                            <div class="award-runner-up">2ìœ„: ${runnerUp}${runnerUp !== '-' ? (allPlayersData.find(p => p.name === runnerUp)?.isFemale ? '*' : '') : ''} (${key === 'dominantForce' ? 'ì••ë„ ì ìˆ˜' : key === 'winKing' ? 'ìŠ¹ì°¨' : key === 'playerOfMonth' ? 'ì›”ê°„ ì ìˆ˜' : key === 'mostImproved' ? 'ê°œì„  ì ìˆ˜' : key === 'mvpMale' || key === 'mvpFemale' ? 'MVP ì ìˆ˜' : key === 'peakMmr' ? 'ìµœê³  MMR' : 'ì ìˆ˜'}: ${runnerUpValue})</div>
                        `;
                        grid.appendChild(card);
                    }
                }

                setupMmrPlayerSelector();
                if (fullMmrHistory.length) {
                    renderMmrChart(fullMmrHistory, allPlayersData.slice(0, 1).map(p => p.name));
                } else {
                    console.warn("MMR íˆìŠ¤í† ë¦¬ ë°ì´í„° ì—†ìŒ, ê¸°ë³¸ ì°¨íŠ¸ ë Œë”ë§");
                    fullMmrHistory = [{ createdAt: new Date().toISOString(), [normalizePlayerName(allPlayersData[0]?.name || "ê¸°ë³¸ ì„ ìˆ˜").replace(/\./g, '_')]: 1500 }];
                    renderMmrChart(fullMmrHistory, [allPlayersData[0]?.name || "ê¸°ë³¸ ì„ ìˆ˜"]);
                }
                console.log("loadDashboard ì™„ë£Œ");
            } catch (e) {
                console.error("loadDashboard ì „ì²´ ì‹¤íŒ¨:", e.message);
                showToast("ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨! ë„¤íŠ¸ì›Œí¬ ë° ë°ì´í„° í™•ì¸í•˜ì„¸ìš”.");
            }
        };

        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOMContentLoaded ì´ë²¤íŠ¸ ë°œìƒ, DOM ë¡œë“œ ì™„ë£Œ");
            const savedTheme = localStorage.getItem('theme') || 'dark';
            applyTheme(savedTheme);
            loadDashboard();
            document.getElementById('theme-toggle').addEventListener('click', () => applyTheme(document.documentElement.getAttribute('data-theme') === 'dark' ? 'light' : 'dark'));
        });
    </script>
</body>
</html>