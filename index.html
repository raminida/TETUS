<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><script type="text/javascript">
    var gk_isXlsx = false;
    var gk_xlsxFileLookup = {};
    var gk_fileData = {};
    function filledCell(cell) {
      return cell !== '' && cell != null;
    }
    function loadFileData(filename) {
      if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
          try {
              var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
              var firstSheetName = workbook.SheetNames[0];
              var worksheet = workbook.Sheets[firstSheetName];
              var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
              var filteredData = jsonData.filter(row => row.some(filledCell));
              var headerRowIndex = filteredData.findIndex((row, index) =>
                row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
              );
              if (headerRowIndex === -1 || headerRowIndex > 25) {
                headerRowIndex = 0;
              }
              var csv = XLSX.utils.sheet_to_csv(XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)), { header: 1 });
              console.log(`XLSX 파일 ${filename} 파싱 성공`);
              return csv;
          } catch (e) {
              console.error("XLSX 파싱 오류:", e.name, e.message, e.stack);
              showToast(`XLSX 파싱 실패: ${e.message || '알 수 없는 오류'}`);
              return "";
          }
      }
      return gk_fileData[filename] || "";
    }
</script><!DOCTYPE html>
<html lang="ko" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2025 테투스</title>
    <script src="https://t1.kakaocdn.net/kakao_js_sdk/2.7.2/kakao.min.js" integrity="sha384-y3tIif2B4242xI/mS8d43/p/a1uBoL3w7sL2rS4z0nBjwA/2/g8L/DTrb1JScC4k" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700;900&family=Poppins:wght@600;700&display=stylesheet" rel="stylesheet">
    <style>
        :root {
            --bg-color: #121212; --surface-color: #1E1E1E; --primary-color: #4CAF50; --primary-variant-color: #81C784; --secondary-color: #FFFFFF; --text-color: #E0E0E0; --text-secondary-color: #A0A0A0; --accent-gold: #FFD700; --border-color: #333333; --shadow-color: rgba(0, 0, 0, 0.5);
            --spacing-sm: 8px; --spacing-md: 12px; --spacing-lg: 20px; --radius: 8px;
        }
        html[data-theme="light"] {
            --bg-color: #F0F4F8; --surface-color: #FFFFFF; --primary-color: #1A3C34; --primary-variant-color: #2A6B5B; --text-color: #1F2937; --text-secondary-color: #6B7280; --border-color: #E5E7EB; --shadow-color: rgba(0, 0, 0, 0.1);
        }
        body { font-family: 'Noto Sans KR', sans-serif; background-color: var(--bg-color); color: var(--text-color); margin: 0; padding: var(--spacing-md); transition: background-color 0.3s, color 0.3s; }
        .container { max-width: 1200px; margin: 0 auto; }
        h1 { font-family: 'Poppins', sans-serif; font-size: 2.8rem; font-weight: 900; text-align: center; color: var(--secondary-color); background: linear-gradient(135deg, var(--primary-color), var(--primary-variant-color)); -webkit-background-clip: text; background-clip: text; color: transparent; padding-top: var(--spacing-lg); margin-bottom: 2rem; letter-spacing: -2px; text-shadow: 2px 2px 10px var(--shadow-color); }
        .section { background: var(--surface-color); padding: var(--spacing-lg); border-radius: var(--radius); box-shadow: 0 10px 30px var(--shadow-color); margin-bottom: 2.5rem; border: 1px solid var(--border-color); }
        h2 { font-family: 'Poppins', sans-serif; font-size: 1.8rem; font-weight: 700; color: var(--primary-color); margin-bottom: var(--spacing-sm); padding-bottom: var(--spacing-sm); border-bottom: 2px solid var(--border-color); }
        details { margin-bottom: 1rem; border-radius: var(--radius); overflow: hidden; border: 1px solid var(--border-color); }
        details summary { padding: var(--spacing-md) 15px; cursor: pointer; font-size: 1.1rem; font-weight: 700; outline: none; transition: background 0.3s ease, color 0.3s ease; background: linear-gradient(135deg, #2a2a2a, #222222); color: var(--secondary-color); }
        html[data-theme="light"] details summary { background: linear-gradient(135deg, #f9f9f9, #f1f1f1); color: var(--text-color); }
        details[open] > summary { background: var(--primary-color); color: var(--bg-color); }
        html[data-theme="light"] details[open] > summary { color: var(--secondary-color); }
        .round-group-content { padding: 15px 10px 5px 10px; background: rgba(0,0,0,0.1); border-top: 1px solid var(--border-color); }
        html[data-theme="light"] .round-group-content { background: rgba(0,0,0,0.02); }
        .table-wrapper { overflow-x: auto; overflow-y: auto; max-height: 70vh; max-width: 100%; -webkit-overflow-scrolling: touch; }
        table { width: 100%; min-width: 100%; border-collapse: collapse; }
        th, td { padding: var(--spacing-md) 8px; text-align: center; border-bottom: 1px solid var(--border-color); font-size: 0.9rem; white-space: nowrap; }
        #ranking-table thead th { position: sticky; top: 0; background: var(--surface-color); z-index: 10; }
        th { font-family: 'Poppins', sans-serif; background-color: rgba(0, 0, 0, 0.2); color: var(--primary-variant-color); font-weight: 700; }
        html[data-theme="light"] th { background-color: #F9FAFB; }
        .rank-cell { font-weight: 900; color: #FFD700; text-shadow: 0 0 5px rgba(255, 215, 0, 0.5); position: relative; padding-right: 40px; line-height: 1.2; }
        .rank-change { font-size: 0.7rem; position: absolute; right: 5px; top: 50%; transform: translateY(-50%); white-space: nowrap; }
        .rank-up { color: #4CAF50; }
        .rank-down { color: #F44336; }
        .rank-nochange { color: var(--text-secondary-color); }
        #ranking-table th:nth-child(2), #ranking-table td:nth-child(2) { position: sticky; left: 0; background: var(--surface-color); z-index: 1; }
        input[type="text"] { width: 100%; min-width: 50px; max-width: 100px; padding: var(--spacing-sm); background-color: var(--surface-color); border: 1px solid var(--border-color); border-radius: 6px; box-sizing: border-box; color: var(--text-color); font-family: 'Noto Sans KR', sans-serif; text-align: center; }
        input.ranking-player, input.mmr { min-width: 80px; max-width: 120px; }
        input.readonly { background-color: #252525; color: var(--text-secondary-color); font-weight: bold; }
        html[data-theme="light"] input.readonly { background-color: #f0f0f0; }
        .btn-group { display: flex; flex-direction: column; gap: 10px; margin-top: var(--spacing-lg); }
        .btn { display: inline-block; padding: var(--spacing-md) var(--spacing-lg); background: linear-gradient(135deg, var(--primary-color), var(--primary-variant-color)); color: #FFFFFF; text-decoration: none; border-radius: var(--radius); cursor: pointer; font-weight: 700; font-size: 1rem; border: none; text-align: center; }
        html[data-theme="dark"] .btn { color: var(--bg-color); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .update-btn { width: 100%; margin-top: var(--spacing-lg); padding: 15px; background: linear-gradient(135deg, var(--accent-gold), #F5B02E); color: var(--bg-color); border: none; border-radius: var(--radius); font-size: 1.2rem; font-weight: 900; cursor: pointer; }
        .toast { position: fixed; bottom: var(--spacing-lg); left: 50%; transform: translateX(-50%); background: linear-gradient(135deg, #333, #111); color: #fff; padding: var(--spacing-md) 25px; border-radius: 50px; box-shadow: 0 5px 15px var(--shadow-color); opacity: 0; transition: opacity 0.4s, transform 0.4s; font-weight: 700; z-index: 1000; }
        .toast.show { opacity: 1; }
        .championship-star { color: var(--accent-gold); text-shadow: 0 0 5px var(--accent-gold); font-size: 1.1rem; font-weight: 900; }
        .theme-toggle { position: fixed; top: 15px; right: 15px; background: var(--surface-color); border: 1px solid var(--border-color); border-radius: 50%; width: 40px; height: 40px; font-size: 1.5rem; cursor: pointer; color: var(--text-color); display: flex; justify-content: center; align-items: center; z-index: 1000; }
        .ranking-player[value$="*"] { color: var(--primary-variant-color); }
        .ranking-filter { display: flex; gap: var(--spacing-sm); margin-bottom: var(--spacing-md); }
        .filter-btn { padding: var(--spacing-sm) var(--spacing-md); background: var(--surface-color); border: 1px solid var(--border-color); border-radius: var(--radius); cursor: pointer; color: var(--text-color); font-weight: 700; }
        .filter-btn.active { background: var(--primary-color); color: var(--bg-color); }
        .toggle-btn { padding: var(--spacing-sm) var(--spacing-md); margin: var(--spacing-sm) auto; display: block; }
        tr.lower-rank { display: none; }
        tr.lower-rank.show { display: table-row; }
        .court-section { display: flex; justify-content: space-between; gap: var(--spacing-md); flex-wrap: wrap; }
        .court-table { width: 48%; }
        .player-input-section { margin-bottom: var(--spacing-md); }
        .player-input-section input { margin-right: var(--spacing-sm); margin-bottom: var(--spacing-sm); flex: 1; min-width: 50px; max-width: 90px; }
        .player-input-section .player-label { white-space: nowrap; margin-right: var(--spacing-md); }
        .player-input-section .player-inputs { display: flex; flex-wrap: wrap; gap: var(--spacing-sm); }
        .schedule-table td input.player1, .schedule-table td input.player2,
        .schedule-table td input.player3, .schedule-table td input.player4 { min-width: 80px; }
        .schedule-table td input.score { min-width: 70px; font-size: 0.7rem; }
        @media screen and (max-width: 600px) {
            th, td { padding: 6px 4px; font-size: 0.8rem; }
            input[type="text"] { min-width: 40px; max-width: 80px; font-size: 0.8rem; }
            input.ranking-player, input.mmr { min-width: 70px; max-width: 100px; }
            .player-input-section input { min-width: 40px; max-width: 90px; }
            .player-input-section .player-label { display: block; width: 100%; }
            .schedule-table { min-width: 100%; }
            .schedule-table td input.player1, .schedule-table td input.player2,
            .schedule-table td input.player3, .schedule-table td input.player4 { min-width: 60px; }
            .schedule-table td input.score { min-width: 50px; }
            .court-table { width: 100%; }
            .btn { padding: 8px 12px; font-size: 0.9rem; }
            h1 { font-size: 2rem; }
            h2 { font-size: 1.5rem; }
        }
    </style>
</head>
<body>
    <button class="theme-toggle" id="theme-toggle">☀️</button>
    <div class="container">
        <h1>2025 테투스</h1>
        <div class="section">
            <h2>경기 일정</h2>
            <div id="schedule-container"></div>
            <button id="save-all" class="btn">모든 데이터 저장</button>
            <button id="update-ranking" class="btn update-btn">순위 업데이트</button>
        </div>
        <div class="section">
            <h2>시즌 순위표</h2>
            <div class="ranking-filter">
                <button class="filter-btn active" data-filter="all">통합 순위</button>
                <button class="filter-btn" data-filter="male">남자 순위</button>
                <button class="filter-btn" data-filter="female">여자 순위</button>
            </div>
            <div class="table-wrapper">
                <table id="ranking-table">
                    <thead><tr><th>순위</th><th>선수</th><th>MMR</th><th>우승</th><th>승</th><th>패</th><th>승률(%)</th><th>경기당 평균 게임 득실</th><th>접전률(%)</th><th>압도승률(%)</th><th>최고 파트너</th></tr></thead>
                    <tbody></tbody>
                </table>
            </div>
            <button id="toggle-rankings" class="btn toggle-btn">더보기</button>
            <div class="btn-group">
                <a href="dash.html" class="btn" id="dashboard-link">통계 대시보드</a>
                <button id="kakao-share-btn" class="btn">카카오톡 공유</button>
                <button id="download-csv" class="btn">CSV 다운로드</button>
            </div>
        </div>
    </div>
    <div id="toast" class="toast"></div>

<script type="module">
    // XLSX 파싱 로직
    let gk_isXlsx = false;
    let gk_xlsxFileLookup = {};
    let gk_fileData = {};
    function filledCell(cell) {
        return cell !== '' && cell != null;
    }
    function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                const workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                const firstSheetName = workbook.SheetNames[0];
                const worksheet = workbook.Sheets[firstSheetName];
                const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                const filteredData = jsonData.filter(row => row.some(filledCell));
                let headerRowIndex = filteredData.findIndex((row, index) =>
                    row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                    headerRowIndex = 0;
                }
                const csv = XLSX.utils.sheet_to_csv(XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)), { header: 1 });
                console.log(`XLSX 파일 ${filename} 파싱 성공`);
                return csv;
            } catch (e) {
                console.error("XLSX 파싱 오류:", e.name, e.message, e.stack);
                showToast(`XLSX 파싱 실패: ${e.message || '알 수 없는 오류'}`);
                return "";
            }
        }
        return gk_fileData[filename] || "";
    }

    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-app.js";
    import { getFirestore, doc, setDoc, getDoc, collection, serverTimestamp, writeBatch, setLogLevel } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-firestore.js";

    setLogLevel('debug');

    const firebaseConfig = {
        apiKey: "AIzaSyCj33GM2pM2-Vz1Fmh6eyMwQkWjByA7xdw",
        authDomain: "tetus-c91f0.firebaseapp.com",
        projectId: "tetus-c91f0",
        storageBucket: "tetus-c91f0.firebasestorage.app",
        messagingSenderId: "877913022272",
        appId: "1:877913022272:web:ec685d63235c87c3c1e4a5",
        measurementId: "G-7FJY9EKPV5"
    };

    let db;
    try {
        db = getFirestore(initializeApp(firebaseConfig));
        console.log("Firebase 초기화 성공!");
    } catch (e) {
        console.error("Firebase 초기화 실패:", e.name, e.code, e.message, e.stack);
        showToast(`Firebase 초기화 실패: ${e.message || '알 수 없는 오류'}`);
    }

    let currentFilter = 'all';

    function showToast(message) {
        const toast = document.getElementById('toast');
        if (toast) {
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 3000);
        } else {
            console.warn("Toast 요소 없음!");
        }
    }

    function generateMatches(players) {
        if (players.length !== 6) return [];
        const playerData = players.map(name => {
            const player = document.querySelector(`.ranking-player[value="${name}${name.includes('*') ? '*' : ''}"]`)?.parentElement;
            const mmr = player ? parseInt(player.querySelector('.mmr').value) || 1500 : 1500;
            const isFemale = name.includes('*');
            return { name: name.replace('*', ''), mmr, isFemale };
        });

        // 성별 분류
        const females = playerData.filter(p => p.isFemale).sort((a, b) => b.mmr - a.mmr);
        const males = playerData.filter(p => !p.isFemale).sort((a, b) => b.mmr - a.mmr);

        let matches = [];
        if (females.length >= 4) {
            // 여여 vs 여여 우선
            const femalePairs = [];
            for (let i = 0; i < females.length; i += 2) {
                if (i + 1 < females.length) femalePairs.push([females[i], females[i + 1]]);
            }
            matches = femalePairs.map(pair => [pair[0].name + (pair[0].isFemale ? '*' : ''), pair[1].name + (pair[1].isFemale ? '*' : '')]);
        } else if (females.length > 0 && males.length > 0) {
            // 남녀 vs 남녀
            const mixedPairs = [];
            let femaleIndex = 0, maleIndex = 0;
            while (mixedPairs.length < 3 && (femaleIndex < females.length || maleIndex < males.length)) {
                const p1 = femaleIndex < females.length ? females[femaleIndex++] : males[maleIndex++];
                const p2 = maleIndex < males.length ? males[maleIndex++] : females[femaleIndex++];
                if (p1 && p2) mixedPairs.push([p1, p2]);
            }
            matches = mixedPairs.map(pair => [
                pair[0].name + (pair[0].isFemale ? '*' : ''),
                pair[1].name + (pair[1].isFemale ? '*' : '')
            ]);
        } else {
            // 남남 vs 남남
            const malePairs = [];
            for (let i = 0; i < males.length; i += 2) {
                if (i + 1 < males.length) malePairs.push([males[i], males[i + 1]]);
            }
            matches = malePairs.map(pair => [pair[0].name, pair[1].name]);
        }

        // MMR 기반 최적화
        matches = matches.map(([p1Name, p2Name]) => {
            const p1 = playerData.find(p => p.name === p1Name.replace('*', '') && p.isFemale === p1Name.includes('*'));
            const p2 = playerData.find(p => p.name === p2Name.replace('*', '') && p.isFemale === p2Name.includes('*'));
            if (!p1 || !p2) return [p1Name, p2Name];
            const opponents = playerData.filter(p => p !== p1 && p !== p2);
            const [op1, op2] = opponents.sort((a, b) => {
                const teamMMR = (p1.mmr + p2.mmr);
                const aDiff = Math.abs(teamMMR - (a.mmr + (opponents.find(op => op !== a)?.mmr || 1500)));
                const bDiff = Math.abs(teamMMR - (b.mmr + (opponents.find(op => op !== b)?.mmr || 1500)));
                return aDiff - bDiff;
            }).slice(0, 2);
            return [p1Name, p2Name, op1.name + (op1.isFemale ? '*' : ''), op2.name + (op2.isFemale ? '*' : '')];
        });

        return matches;
    }

    function generateFinalMatches(aCourtPlayers, bCourtPlayers, aCourtWins, bCourtWins) {
        const aSorted = aCourtPlayers.map((p, i) => ({ name: p, wins: aCourtWins[p] || 0 }))
            .sort((a, b) => b.wins - a.wins);
        const bSorted = bCourtPlayers.map((p, i) => ({ name: p, wins: bCourtWins[p] || 0 }))
            .sort((a, b) => b.wins - a.wins);
        
        const finalAMatch = [
            aSorted[0].name, aSorted[1].name,
            bSorted[0].name, bSorted[1].name
        ];
        const finalBMatch = [
            aSorted[2].name, aSorted[3].name,
            bSorted[2].name, bSorted[3].name
        ];
        return { finalA: finalAMatch, finalB: finalBMatch };
    }

    function createScheduleRounds() {
        const container = document.getElementById('schedule-container');
        if (!container) {
            console.error("schedule-container 요소 없음!");
            showToast("스케줄 컨테이너 오류!");
            return;
        }
        let roundsHtml = '';
        for (let group = 0; group < 3; group++) {
            const startRound = group * 10 + 1;
            const endRound = Math.min((group + 1) * 10, 30);
            roundsHtml += `<details class="round-group"><summary>${startRound} ~ ${endRound}회차</summary><div class="round-group-content">`;
            for (let i = startRound; i <= endRound; i++) {
                roundsHtml += `
                <details>
                    <summary>${i}회차</summary>
                    <div class="player-input-section">
                        <h3>참가자 입력</h3>
                        <div class="player-label">A코트 (6명):</div>
                        <div class="player-inputs">
                            ${Array(6).fill().map((_, idx) => `<input type="text" placeholder="이름 ${idx + 1}" class="a-player" data-round-id="${i}" data-index="${idx}">`).join('')}
                            <button class="btn auto-match-btn" data-round-id="${i}" data-court="A">A코트 자동 배치</button>
                        </div>
                        <div class="player-label">B코트 (6명):</div>
                        <div class="player-inputs" style="margin-bottom: var(--spacing-md);">
                            ${Array(6).fill().map((_, idx) => `<input type="text" placeholder="이름 ${idx + 1}" class="b-player" data-round-id="${i}" data-index="${idx}">`).join('')}
                            <button class="btn auto-match-btn" data-round-id="${i}" data-court="B">B코트 자동 배치</button>
                        </div>
                        <button class="btn auto-final-btn" data-round-id="${i}">결승 자동 배치</button>
                    </div>
                    <div class="court-section">
                        <div class="court-table">
                            <h3>A코트 (6경기)</h3>
                            <div class="table-wrapper">
                                <table class="schedule-table a-court" data-round-id="${i}" data-court="A">
                                    <thead><tr><th>Player 1</th><th>Player 2</th><th>vs</th><th>Player 3</th><th>Player 4</th><th>Score</th></tr></thead>
                                    <tbody>
                                        ${Array(6).fill().map(() => `
                                            <tr><td><input type="text" placeholder="이름" class="player1"></td><td><input type="text" placeholder="이름" class="player2"></td><td>vs</td><td><input type="text" placeholder="이름" class="player3"></td><td><input type="text" placeholder="이름" class="player4"></td><td><input type="text" placeholder="4-2" class="score"></td></tr>
                                        `).join('')}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                        <div class="court-table">
                            <h3>B코트 (6경기)</h3>
                            <div class="table-wrapper">
                                <table class="schedule-table b-court" data-round-id="${i}" data-court="B">
                                    <thead><tr><th>Player 1</th><th>Player 2</th><th>vs</th><th>Player 3</th><th>Player 4</th><th>Score</th></tr></thead>
                                    <tbody>
                                        ${Array(6).fill().map(() => `
                                            <tr><td><input type="text" placeholder="이름" class="player1"></td><td><input type="text" placeholder="이름" class="player2"></td><td>vs</td><td><input type="text" placeholder="이름" class="player3"></td><td><input type="text" placeholder="이름" class="player4"></td><td><input type="text" placeholder="4-2" class="score"></td></tr>
                                        `).join('')}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                    <div class="court-section">
                        <div class="court-table">
                            <h3>결승 (A코트: 상위권)</h3>
                            <div class="table-wrapper">
                                <table class="schedule-table final-a" data-round-id="${i}" data-court="final-A">
                                    <thead><tr><th>Player 1</th><th>Player 2</th><th>vs</th><th>Player 3</th><th>Player 4</th><th>Score</th></tr></thead>
                                    <tbody>
                                        <tr><td><input type="text" placeholder="이름" class="player1"></td><td><input type="text" placeholder="이름" class="player2"></td><td>vs</td><td><input type="text" placeholder="이름" class="player3"></td><td><input type="text" placeholder="이름" class="player4"></td><td><input type="text" placeholder="4-2" class="score"></td></tr>
                                    </tbody>
                                </table>
                            </div>
                        </div>
                        <div class="court-table">
                            <h3>결승 (B코트: 하위권)</h3>
                            <div class="table-wrapper">
                                <table class="schedule-table final-b" data-round-id="${i}" data-court="final-B">
                                    <thead><tr><th>Player 1</th><th>Player 2</th><th>vs</th><th>Player 3</th><th>Player 4</th><th>Score</th></tr></thead>
                                    <tbody>
                                        <tr><td><input type="text" placeholder="이름" class="player1"></td><td><input type="text" placeholder="이름" class="player2"></td><td>vs</td><td><input type="text" placeholder="이름" class="player3"></td><td><input type="text" placeholder="이름" class="player4"></td><td><input type="text" placeholder="4-2" class="score"></td></tr>
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                </details>`;
            }
            roundsHtml += `</div></details>`;
        }
        container.innerHTML = roundsHtml;
        console.log("회차 일정표 렌더링 완료!");
    }

    function createRankingRows() {
        const rankingBody = document.querySelector('#ranking-table tbody');
        if (!rankingBody) {
            console.error("ranking-table tbody 요소 없음!");
            showToast("순위표 오류!");
            return;
        }
        let rowsHtml = '';
        for (let i = 1; i <= 50; i++) {
            rowsHtml += `
            <tr${i > 20 ? ' class="lower-rank"' : ''}>
                <td class="rank-cell">${i}<span class="rank-change"></span></td>
                <td><input type="text" placeholder="선수 ${i}" class="ranking-player"></td>
                <td><input type="text" class="mmr readonly" readonly></td>
                <td><span class="championship-star"></span></td>
                <td><input type="text" class="wins readonly" readonly></td>
                <td><input type="text" class="losses readonly" readonly></td>
                <td><input type="text" class="win-rate readonly" readonly></td>
                <td><input type="text" class="avg-game-diff readonly" readonly></td>
                <td><input type="text" class="close-rate readonly" readonly></td>
                <td><input type="text" class="dominant-wins readonly" readonly></td>
                <td><input type="text" class="best-partner readonly" readonly></td>
            </tr>`;
        }
        rankingBody.innerHTML = rowsHtml;
        console.log("순위표 렌더링 완료!");
    }

    async function saveAllData() {
        if (!db) {
            showToast('DB 연결 실패!');
            return;
        }
        const saveAllBtn = document.getElementById('save-all');
        saveAllBtn.disabled = true;
        try {
            const batch = writeBatch(db);

            const scheduleData = [];
            document.querySelectorAll('.schedule-table').forEach(table => {
                const roundId = table.getAttribute('data-round-id');
                const court = table.getAttribute('data-court');
                const rows = table.querySelectorAll('tbody tr');
                rows.forEach(row => {
                    const player1 = row.querySelector('.player1').value.trim();
                    const player2 = row.querySelector('.player2').value.trim();
                    const player3 = row.querySelector('.player3').value.trim();
                    const player4 = row.querySelector('.player4').value.trim();
                    const scoreInput = row.querySelector('.score').value.trim();
                    if (player1 && player2 && player3 && player4) {
                        scheduleData.push({
                            round: parseInt(roundId),
                            court,
                            players: [player1, player2, player3, player4],
                            score: scoreInput || ''
                        });
                    }
                });
            });
            const scheduleDocRef = doc(db, 'league', 'data', 'schedule', 'v1');
            batch.set(scheduleDocRef, { matches: scheduleData, timestamp: serverTimestamp() }, { merge: true });

            const matchDataList = [];
            document.querySelectorAll('.schedule-table').forEach(table => {
                const rows = table.querySelectorAll('tbody tr');
                rows.forEach(row => {
                    const player1 = row.querySelector('.player1').value.trim();
                    const player2 = row.querySelector('.player2').value.trim();
                    const player3 = row.querySelector('.player3').value.trim();
                    const player4 = row.querySelector('.player4').value.trim();
                    const scoreInput = row.querySelector('.score').value.trim();
                    if (player1 && player2 && player3 && player4 && scoreInput && /^\d+-\d+$/.test(scoreInput)) {
                        const [score1, score2] = scoreInput.split('-').map(Number);
                        const winner = score1 > score2 ? (player1 || player2) : (player3 || player4);
                        const gameDiff = Math.abs(score1 - score2);
                        matchDataList.push({
                            player1: player1 || player2,
                            player2: player3 || player4,
                            winner,
                            gameDiff,
                            timestamp: serverTimestamp()
                        });
                    }
                });
            });
            matchDataList.forEach((match, index) => {
                const matchDocRef = doc(collection(db, 'league/matches/data'), `match_${Date.now()}_${index}`);
                batch.set(matchDocRef, match);
            });

            const rankingRows = document.querySelectorAll('#ranking-table tbody tr');
            const rankingData = Array.from(rankingRows).map(row => {
                const rawName = row.querySelector('.ranking-player').value.trim();
                const name = rawName.replace(/\*/g, '');
                return {
                    name,
                    mmr: row.querySelector('.mmr').value || '0',
                    championships: row.querySelector('.championship-star')?.dataset.count || '0',
                    wins: row.querySelector('.wins').value || '0',
                    losses: row.querySelector('.losses').value || '0',
                    winRate: row.querySelector('.win-rate').value || '0',
                    avgGameDiff: row.querySelector('.avg-game-diff').value || '0',
                    closeRate: row.querySelector('.close-rate').value || '0',
                    dominantWins: row.querySelector('.dominant-wins').value || '0',
                    bestPartner: row.querySelector('.best-partner').value || '-',
                    isFemale: rawName.includes('*'),
                    seasonMMRIncrease: parseFloat(row.querySelector('.mmr').dataset.seasonMMRIncrease) || 0
                };
            }).filter(player => player.name);
            const rankingDocRef = doc(db, 'league', 'data', 'rankings', 'v1');
            batch.set(rankingDocRef, { players: rankingData, timestamp: serverTimestamp() }, { merge: true });

            const rankingHistoryDocRef = doc(db, 'league', 'data', 'rankingHistory', 'v1');
            const rankingHistorySnap = await getDoc(rankingHistoryDocRef);
            const existingHistory = rankingHistorySnap.exists() ? rankingHistorySnap.data().snapshots || [] : [];
            const newSnapshot = {
                snapshotId: existingHistory.length + 1,
                createdAt: new Date().toISOString(),
                rankings: rankingData.map((player, index) => ({
                    name: player.name,
                    rank: index + 1
                }))
            };
            existingHistory.push(newSnapshot);
            batch.set(rankingHistoryDocRef, { snapshots: existingHistory }, { merge: true });

            await batch.commit();
            console.log("모든 데이터 저장 성공!");
            showToast("모든 데이터 저장 완료!");
        } catch (e) {
            console.error("데이터 저장 실패:", e.name, e.code, e.message, e.stack);
            showToast(`데이터 저장 실패: ${e.message || '알 수 없는 오류'}`);
            if (e.code === 'unavailable') {
                console.log("오프라인 모드: 데이터가 로컬 캐시에 큐잉됨.");
                showToast("오프라인 모드: 데이터가 나중에 동기화됩니다!");
            }
        } finally {
            saveAllBtn.disabled = false;
        }
    }

    async function loadData() {
        if (!db) {
            showToast("DB 연결 실패");
            return;
        }
        try {
            const scheduleDoc = await getDoc(doc(db, 'league', 'data', 'schedule', 'v1'));
            if (scheduleDoc.exists()) {
                const scheduleData = scheduleDoc.data().matches || [];
                document.querySelectorAll('.schedule-table').forEach(table => {
                    const roundId = table.getAttribute('data-round-id');
                    const court = table.getAttribute('data-court');
                    const matches = scheduleData.filter(m => m.round == roundId && m.court === court);
                    const rows = table.querySelectorAll('tbody tr');
                    rows.forEach((row, index) => {
                        const match = matches[index];
                        if (match) {
                            row.querySelector('.player1').value = match.players[0] || '';
                            row.querySelector('.player2').value = match.players[1] || '';
                            row.querySelector('.player3').value = match.players[2] || '';
                            row.querySelector('.player4').value = match.players[3] || '';
                            row.querySelector('.score').value = match.score || '';
                        }
                    });
                });
                console.log("스케줄 데이터 로드 완료!");
            } else {
                console.warn("스케줄 데이터 없음!");
                showToast("스케줄 데이터가 없습니다!");
            }

            const rankingDoc = await getDoc(doc(db, 'league', 'data', 'rankings', 'v1'));
            if (rankingDoc.exists()) {
                const rankingData = rankingDoc.data().players || [];
                document.querySelectorAll('#ranking-table tbody tr').forEach((row, index) => {
                    const player = rankingData[index];
                    if (player) {
                        row.querySelector('.ranking-player').value = player.isFemale ? `${player.name}*` : player.name;
                        row.querySelector('.mmr').value = player.mmr || '0';
                        row.querySelector('.mmr').dataset.seasonMMRIncrease = player.seasonMMRIncrease.toFixed(2);
                        const champStar = row.querySelector('.championship-star');
                        champStar.dataset.count = player.championships;
                        champStar.textContent = player.championships == 1 ? '⭐' : player.championships > 1 ? `⭐(${player.championships})` : '';
                        row.querySelector('.wins').value = player.wins || '0';
                        row.querySelector('.losses').value = player.losses || '0';
                        row.querySelector('.win-rate').value = player.winRate || '0';
                        row.querySelector('.avg-game-diff').value = player.avgGameDiff || '0';
                        row.querySelector('.close-rate').value = player.closeRate || '0';
                        row.querySelector('.dominant-wins').value = player.dominantWins || '0';
                        row.querySelector('.best-partner').value = player.bestPartner || '-';
                        row.cells[0].innerHTML = `${index + 1}<span class="rank-change rank-nochange">–</span>`;
                    }
                });
                console.log("랭킹 데이터 로드 완료!");
            } else {
                console.warn("랭킹 데이터 없음!");
                showToast("랭킹 데이터가 없습니다!");
            }
        } catch (e) {
            console.error("로드 실패:", e.name, e.code, e.message, e.stack);
            showToast(`데이터 로드 실패: ${e.message || '알 수 없는 오류'}`);
        }
    }

    async function updateRanking() {
        const updateRankingBtn = document.getElementById('update-ranking');
        updateRankingBtn.disabled = true;

        const BASE_MMR = 1500;
        const BASE_K = 28;
        const BASE_GAMES = 30;
        const MALE_TEAM_WIN_HANDICAP = 0.5;
        const MIXED_TEAM_LOSS_HANDICAP = 0.5;
        const HANDICAP_BASE_POINT = 1500;
        const HANDICAP_ZERO_POINT = 1650;
        const HANDICAP_MAX = 150;

        const players = {};
        const partnerStats = {};

        let previousRankings = {};
        try {
            const rankingHistoryDoc = await getDoc(doc(db, 'league', 'data', 'rankingHistory', 'v1'));
            if (rankingHistoryDoc.exists()) {
                const snapshots = rankingHistoryDoc.data().snapshots || [];
                const latestSnapshot = snapshots[snapshots.length - 1];
                if (latestSnapshot && latestSnapshot.rankings) {
                    latestSnapshot.rankings.forEach(player => {
                        previousRankings[player.name] = player.rank;
                    });
                }
            }
        } catch (e) {
            console.error("랭킹 히스토리 로드 실패:", e.name, e.code, e.message, e.stack);
        }

        document.querySelectorAll('#ranking-table tbody tr').forEach(row => {
            const rawName = row.querySelector('.ranking-player').value.trim();
            const name = rawName.replace(/\*/g, '');
            if (name && !players[name]) {
                players[name] = {
                    name,
                    wins: 0,
                    losses: 0,
                    winRate: 0,
                    gameDiff: 0,
                    avgGameDiff: 0,
                    mmr: BASE_MMR,
                    championships: 0,
                    closeWins: 0,
                    closeSets: 0,
                    closeLosses: 0,
                    dominantWins: 0,
                    totalSets: 0,
                    isFemale: rawName.includes('*'),
                    seasonMMRIncrease: 0
                };
                partnerStats[name] = {};
            }
        });

        const scheduleTables = document.querySelectorAll('.schedule-table');
        const roundCourts = {};
        scheduleTables.forEach(table => {
            const roundId = table.getAttribute('data-round-id');
            const court = table.getAttribute('data-court');
            if (!roundCourts[roundId]) roundCourts[roundId] = {};
            roundCourts[roundId][court] = table;
        });

        for (let roundId in roundCourts) {
            const courts = roundCourts[roundId];
            const aCourt = courts['A'];
            const bCourt = courts['B'];
            const finalACourt = courts['final-A'];
            const finalBCourt = courts['final-B'];

            const playerWins = {};
            let roundHasMixedMatch = false;

            const processCourt = (table) => {
                const rows = table.querySelectorAll('tbody tr');
                rows.forEach(row => {
                    const p1Raw = row.querySelector('.player1').value.trim();
                    const p2Raw = row.querySelector('.player2').value.trim();
                    const p3Raw = row.querySelector('.player3').value.trim();
                    const p4Raw = row.querySelector('.player4').value.trim();
                    const score = row.querySelector('.score').value.trim();

                    const p1 = p1Raw.replace(/\*/g, '');
                    const p2 = p2Raw.replace(/\*/g, '');
                    const p3 = p3Raw.replace(/\*/g, '');
                    const p4 = p4Raw.replace(/\*/g, '');

                    if (!p1 || !p2 || !p3 || !p4 || !/^\d+-\d+$/.test(score)) return;

                    [p1, p2, p3, p4].forEach((name, idx) => {
                        if (name && !players[name]) {
                            players[name] = {
                                name,
                                wins: 0,
                                losses: 0,
                                winRate: 0,
                                gameDiff: 0,
                                avgGameDiff: 0,
                                mmr: BASE_MMR,
                                championships: 0,
                                closeWins: 0,
                                closeSets: 0,
                                closeLosses: 0,
                                dominantWins: 0,
                                totalSets: 0,
                                isFemale: [p1Raw, p2Raw, p3Raw, p4Raw][idx].includes('*'),
                                seasonMMRIncrease: 0
                            };
                            partnerStats[name] = {};
                        }
                    });

                    const team1IsMixed = p1Raw.includes('*') || p2Raw.includes('*');
                    const team2IsMixed = p3Raw.includes('*') || p4Raw.includes('*');
                    const team1IsMale = !team1IsMixed;
                    const team2IsMale = !team2IsMixed;

                    if (team1IsMixed || team2IsMixed) roundHasMixedMatch = true;

                    const getDynamicHandicap = (mmr) => {
                        if (mmr >= HANDICAP_ZERO_POINT) return 0;
                        if (mmr <= HANDICAP_BASE_POINT) return HANDICAP_MAX;
                        const progress = (mmr - HANDICAP_BASE_POINT) / (HANDICAP_ZERO_POINT - HANDICAP_BASE_POINT);
                        return Math.max(0, HANDICAP_MAX * (1 - progress));
                    };

                    let team1MMR = (players[p1].mmr + players[p2].mmr) / 2;
                    let team2MMR = (players[p3].mmr + players[p4].mmr) / 2;
                    let effectiveTeam1MMR = team1MMR;
                    let effectiveTeam2MMR = team2MMR;

                    if (team1IsMixed) {
                        let handicap = 0;
                        if (p1Raw.includes('*')) handicap += getDynamicHandicap(players[p1].mr);
                        if (p2Raw.includes('*')) handicap += getDynamicHandicap(players[p2].mmr);
                        effectiveTeam1MMR += handicap / (p1Raw.includes('*') && p2Raw.includes('*') ? 2 : 1);
                        effectiveTeam1MMR *= 1.5;
                    }
                    if (team2IsMixed) {
                        let handicap = 0;
                        if (p3Raw.includes('*')) handicap += getDynamicHandicap(players[p3].mmr);
                        if (p4Raw.includes('*')) handicap += getDynamicHandicap(players[p4].mmr);
                        effectiveTeam2MMR += handicap / (p3Raw.includes('*') && p4Raw.includes('*') ? 2 : 1);
                        effectiveTeam2MMR *= 1.5;
                    }

                    const expected1 = 1 / (1 + Math.pow(10, (effectiveTeam2MMR - effectiveTeam1MMR) / 400));
                    const [score1, score2] = score.split('-').map(Number);
                    const actual1 = score1 > score2 ? 1 : 0;
                    const gameDiff = Math.abs(score1 - score2);
                    const scoreWeight = 0.8 + (gameDiff / 4) * 0.7;

                    const updatePlayerMMR = (player, opponentTeamMMR, isWinner) => {
                        const totalGames = player.wins + player.losses;
                        let K = BASE_K / (1 + Math.log10(totalGames / BASE_GAMES + 1));
                        if (player.mmr > 1800) {
                            K *= Math.max(0.3, 1 - (player.mmr - 1800) / 1000);
                        }
                        const expectedWinRate = 1 / (1 + Math.pow(10, (opponentTeamMMR - player.mmr) / 400));
                        let mmrChange = K * ((isWinner ? 1 : 0) - expectedWinRate);
                        let opponentWeight = Math.min(1, opponentTeamMMR / player.mmr);
                        if (player.mmr > 1800) {
                            opponentWeight *= Math.max(0.5, 1 - (player.mmr - 1800) / 2000);
                        }
                        mmrChange *= opponentWeight * scoreWeight;
                        return mmrChange;
                    };

                    let mmrChange1 = updatePlayerMMR(players[p1], team2MMR, actual1);
                    let mmrChange2 = updatePlayerMMR(players[p2], team2MMR, actual1);
                    let mmrChange3 = updatePlayerMMR(players[p3], team1MMR, 1 - actual1);
                    let mmrChange4 = updatePlayerMMR(players[p4], team1MMR, 1 - actual1);

                    if (team1IsMale && team2IsMixed && actual1 === 1) {
                        mmrChange1 *= MALE_TEAM_WIN_HANDICAP;
                        mmrChange2 *= MALE_TEAM_WIN_HANDICAP;
                        mmrChange3 *= MALE_TEAM_WIN_HANDICAP;
                        mmrChange4 *= MALE_TEAM_WIN_HANDICAP;
                    } else if (team2IsMale && team1IsMixed && actual1 === 0) {
                        mmrChange1 *= MALE_TEAM_WIN_HANDICAP;
                        mmrChange2 *= MALE_TEAM_WIN_HANDICAP;
                        mmrChange3 *= MALE_TEAM_WIN_HANDICAP;
                        mmrChange4 *= MALE_TEAM_WIN_HANDICAP;
                    }

                    if (team1IsMixed && actual1 === 0) {
                        mmrChange1 *= MIXED_TEAM_LOSS_HANDICAP;
                        mmrChange2 *= MIXED_TEAM_LOSS_HANDICAP;
                    } else if (team2IsMixed && actual1 === 1) {
                        mmrChange3 *= MIXED_TEAM_LOSS_HANDICAP;
                        mmrChange4 *= MIXED_TEAM_LOSS_HANDICAP;
                    }

                    const isClose = gameDiff === 1 || gameDiff === 2;
                    const isDominant1 = (score1 === 4 && score2 <= 1);
                    const isDominant2 = (score2 === 4 && score1 <= 1);

                    const updatePlayer = (name, isWinner, gameDiff, mmrChangeVal, isCloseGame, isDominantGame) => {
                        if (!players[name]) return;
                        players[name].totalSets++;
                        players[name].gameDiff += gameDiff;
                        players[name].mmr += mmrChangeVal;
                        players[name].seasonMMRIncrease += mmrChangeVal;
                        if (isWinner) {
                            players[name].wins++;
                            if (!playerWins[name]) playerWins[name] = 0;
                            playerWins[name]++;
                            if (isCloseGame) players[name].closeWins++;
                        } else {
                            players[name].losses++;
                            if (isCloseGame) players[name].closeLosses++;
                        }
                        if (isCloseGame) players[name].closeSets++;
                        if (isDominantGame && isWinner) players[name].dominantWins++;
                    };

                    updatePlayer(p1, actual1, score1 - score2, mmrChange1, isClose, isDominant1);
                    updatePlayer(p2, actual1, score1 - score2, mmrChange2, isClose, isDominant1);
                    updatePlayer(p3, 1 - actual1, score2 - score1, mmrChange3, isClose, isDominant2);
                    updatePlayer(p4, 1 - actual1, score2 - score1, mmrChange4, isClose, isDominant2);

                    const updatePartnerStats = (player, partner, isWin, gameDiff) => {
                        if (!partnerStats[player]) partnerStats[player] = {};
                        if (!partnerStats[player][partner]) {
                            partnerStats[player][partner] = { wins: 0, losses: 0, gameDiffSum: 0, matches: 0 };
                        }
                        const stats = partnerStats[player][partner];
                        stats.matches++;
                        stats.gameDiffSum += gameDiff;
                        if (isWin) stats.wins++; else stats.losses++;
                    };

                    if (actual1 > 0) {
                        updatePartnerStats(p1, p2, true, score1 - score2);
                        updatePartnerStats(p2, p1, true, score1 - score2);
                        updatePartnerStats(p3, p4, false, score2 - score1);
                        updatePartnerStats(p4, p3, false, score2 - score1);
                    } else {
                        updatePartnerStats(p1, p2, false, score1 - score2);
                        updatePartnerStats(p2, p1, false, score1 - score2);
                        updatePartnerStats(p3, p4, true, score2 - score1);
                        updatePartnerStats(p4, p3, true, score2 - score1);
                    }
                });
            };

            if (aCourt) processCourt(aCourt);
            if (bCourt) processCourt(bCourt);
            if (finalACourt) processCourt(finalACourt);
            if (finalBCourt) processCourt(finalBCourt);

            const sortedWins = Object.entries(playerWins)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 2)
                .map(([name]) => name);
            sortedWins.forEach(name => {
                if (players[name] && !roundHasMixedMatch) {
                    players[name].championships++;
                }
            });
        }

        let sortedPlayers = Object.values(players).sort((a, b) => b.mmr - a.mmr);
        if (currentFilter === 'male') sortedPlayers = sortedPlayers.filter(p => !p.isFemale);
        else if (currentFilter === 'female') sortedPlayers = sortedPlayers.filter(p => p.isFemale);

        try {
            const historyDocRef = doc(db, 'league', 'data', 'mmrHistory', 'v1');
            const historyDocSnap = await getDoc(historyDocRef);
            const existingHistory = historyDocSnap.exists() ? historyDocSnap.data().snapshots || [] : [];
            const newSnapshot = { 
                game: existingHistory.length + 1,
                createdAt: new Date().toISOString()
            };
            sortedPlayers.forEach(p => {
                if (p.wins > 0 || p.losses > 0) {
                    const cleanName = p.name.replace(/[@.*]+/g, '_').replace(/_+/g, '_').trim();
                    newSnapshot[cleanName] = Math.round(p.mmr);
                }
            });
            if (Object.keys(newSnapshot).length > 1) {
                existingHistory.push(newSnapshot);
                await setDoc(historyDocRef, { snapshots: existingHistory });
                console.log("MMR 히스토리 저장 완료!");
            }
        } catch (e) {
            console.error("MMR 히스토리 저장 실패:", e.name, e.code, e.message, e.stack);
            showToast(`MMR 히스토리 저장 실패: ${e.message || '알 수 없는 오류'}`);
        }

        const rankingRows = document.querySelectorAll('#ranking-table tbody tr');
        rankingRows.forEach((row, index) => {
            const player = sortedPlayers[index];
            if (player) {
                player.avgGameDiff = player.totalSets > 0 ? (player.gameDiff / player.totalSets).toFixed(1) : '0.0';
                const totalGames = player.wins + player.losses;
                player.winRate = totalGames > 0 ? Math.round((player.wins / totalGames) * 100) : 0;
                const currentRank = index + 1;
                const previousRank = previousRankings[player.name] || currentRank;
                const rankChange = previousRank - currentRank;
                let rankChangeText = rankChange > 0 ? `↑${rankChange}` : rankChange < 0 ? `↓${Math.abs(rankChange)}` : '–';
                let rankChangeClass = rankChange > 0 ? 'rank-up' : rankChange < 0 ? 'rank-down' : 'rank-nochange';

                row.cells[0].innerHTML = `${currentRank}<span class="rank-change ${rankChangeClass}">${rankChangeText}</span>`;
                row.querySelector('.ranking-player').value = player.isFemale ? `${player.name}*` : player.name;
                row.querySelector('.mmr').value = Math.round(player.mmr);
                row.querySelector('.mmr').dataset.seasonMMRIncrease = player.seasonMMRIncrease.toFixed(2);
                const champStar = row.querySelector('.championship-star');
                champStar.dataset.count = player.championships;
                champStar.textContent = player.championships == 1 ? '⭐' : player.championships > 1 ? `⭐(${player.championships})` : '';
                row.querySelector('.wins').value = player.wins;
                row.querySelector('.losses').value = player.losses;
                row.querySelector('.win-rate').value = player.winRate;
                row.querySelector('.avg-game-diff').value = player.avgGameDiff;
                row.querySelector('.close-rate').value = player.totalSets >= 2 ? (player.closeSets === 0 ? '0' : Math.round(player.closeSets / player.totalSets * 100)) : '0';
                row.querySelector('.dominant-wins').value = player.totalSets > 0 ? Math.round(player.dominantWins / player.totalSets * 100) : '0';

                let bestPartner = { name: '-', score: -Infinity };
                if (partnerStats[player.name]) {
                    for (const partnerName in partnerStats[player.name]) {
                        const stats = partnerStats[player.name][partnerName];
                        const winRate = stats.matches > 0 ? stats.wins / stats.matches : 0;
                        const avgGameDiff = stats.matches > 0 ? stats.gameDiffSum / stats.matches : 0;
                        const chemistryScore = (winRate * 50) + (avgGameDiff * 2) + (stats.matches * 5);
                        if (chemistryScore > bestPartner.score) {
                            bestPartner = { name: partnerName, score: chemistryScore };
                        }
                    }
                }
                row.querySelector('.best-partner').value = bestPartner.name === '-' ? '데이터 부족' : bestPartner.name.replace(/\*/g, '');
            } else {
                row.cells[0].innerHTML = `${index + 1}<span class="rank-change rank-nochange">–</span>`;
                row.querySelectorAll('input:not([type=button])').forEach(input => input.value = '');
                row.querySelector('.championship-star').textContent = '';
            }
        });

        await saveAllData();
        showToast('순위 업데이트 완료!');
        updateRankingBtn.disabled = false;
    }

    function applyTheme(theme) {
        document.documentElement.setAttribute('data-theme', theme);
        const themeToggle = document.getElementById('theme-toggle');
        if (themeToggle) {
            themeToggle.textContent = theme === 'dark' ? '☀️' : '🌙';
            localStorage.setItem('theme', theme);
        } else {
            console.warn("theme-toggle 요소 없음!");
        }
    }

    function shareOnKakao() {
        console.log("카카오톡 공유 기능 호출");
        // 형의 원본 카카오 공유 로직 삽입 필요
    }

    function downloadCSV() {
        let rankingCSV = '\uFEFF순위,선수,MMR,우승,승,패,승률(%),경기당 평균 게임 득실,접전률(%),압도승률(%),최고 파트너\n';
        document.querySelectorAll('#ranking-table tbody tr').forEach(row => {
            const rawName = row.querySelector('.ranking-player').value.trim();
            const player = rawName.replace(/\*/g, '');
            if (player) {
                const rank = row.cells[0].textContent.split(' ')[0];
                const mmr = row.querySelector('.mmr').value;
                const championships = row.querySelector('.championship-star')?.dataset.count || '0';
                const wins = row.querySelector('.wins').value;
                const losses = row.querySelector('.losses').value;
                const winRate = row.querySelector('.win-rate').value;
                const avgGameDiff = row.querySelector('.avg-game-diff').value;
                const closeRate = row.querySelector('.close-rate').value;
                const dominantWins = row.querySelector('.dominant-wins').value;
                const bestPartner = row.querySelector('.best-partner').value;
                rankingCSV += `${rank},"${player}",${mmr},${championships},${wins},${losses},${winRate},${avgGameDiff},${closeRate},${dominantWins},"${bestPartner}"\n`;
            }
        });

        const blob = new Blob([rankingCSV], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = 'tetus_rankings.csv';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }

    function waitForElements(selector, callback, retries = 10, delay = 100) {
        let attempts = 0;
        function check() {
            const elements = document.querySelectorAll(selector);
            if (elements.length > 0 && document.getElementById('schedule-container') && document.querySelector('#ranking-table tbody')) {
                console.log("DOM 요소 준비 완료:", selector);
                callback();
            } else if (attempts < retries) {
                attempts++;
                console.log(`DOM 요소 대기 중 (${attempts}/${retries})...`);
                setTimeout(check, delay);
            } else {
                console.error("DOM 요소 로드 실패:", selector);
                showToast("페이지 로드 오류!");
            }
        }
        check();
    }

    function setupInputListeners() {
        const saveAllBtn = document.getElementById('save-all');
        const updateRankingBtn = document.getElementById('update-ranking');
        const toggleRankingsBtn = document.getElementById('toggle-rankings');
        if (!saveAllBtn || !updateRankingBtn || !toggleRankingsBtn) {
            console.warn("버튼 요소 없음!");
            showToast("버튼 로드 실패!");
            return;
        }
        saveAllBtn.addEventListener('click', saveAllData);
        updateRankingBtn.addEventListener('click', updateRanking);
        toggleRankingsBtn.addEventListener('click', () => {
            const lowerRanks = document.querySelectorAll('.lower-rank');
            const isVisible = lowerRanks[0]?.classList.contains('show');
            lowerRanks.forEach(row => row.classList.toggle('show'));
            toggleRankingsBtn.textContent = isVisible ? '더보기' : '접기';
        });

        document.querySelectorAll('.filter-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentFilter = btn.dataset.filter;
                loadData();
            });
        });

        document.querySelectorAll('.auto-match-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const roundId = btn.getAttribute('data-round-id');
                const court = btn.getAttribute('data-court');
                const playerInputs = document.querySelectorAll(`.${court.toLowerCase()}-player[data-round-id="${roundId}"]`);
                const players = Array.from(playerInputs).map(input => input.value.trim()).filter(name => name);
                if (players.length !== 6) {
                    showToast(`${court}코트에 6명 입력해야 자동 배치 가능!`);
                    return;
                }
                const matches = generateMatches(players);
                const table = document.querySelector(`.schedule-table.${court.toLowerCase()}-court[data-round-id="${roundId}"]`);
                const rows = table.querySelectorAll('tbody tr');
                rows.forEach((row, index) => {
                    const match = matches[index];
                    if (match) {
                        row.querySelector('.player1').value = match[0] || '';
                        row.querySelector('.player2').value = match[1] || '';
                        row.querySelector('.player3').value = match[2] || '';
                        row.querySelector('.player4').value = match[3] || '';
                    }
                });
                showToast(`${court}코트 경기 배치 완료!`);
            });
        });

        document.querySelectorAll('.auto-final-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const roundId = btn.getAttribute('data-round-id');
                const aPlayers = Array.from(document.querySelectorAll(`.a-player[data-round-id="${roundId}"]`))
                    .map(input => input.value.trim())
                    .filter(name => name);
                const bPlayers = Array.from(document.querySelectorAll(`.b-player[data-round-id="${roundId}"]`))
                    .map(input => input.value.trim())
                    .filter(name => name);
                if (aPlayers.length !== 6 || bPlayers.length !== 6) {
                    showToast('A/B코트에 각각 6명 입력해야 결승 배치 가능!');
                    return;
                }

                const aCourtTable = document.querySelector(`.schedule-table.a-court[data-round-id="${roundId}"]`);
                const bCourtTable = document.querySelector(`.schedule-table.b-court[data-round-id="${roundId}"]`);
                const aCourtWins = {};
                const bCourtWins = {};

                [aCourtTable, bCourtTable].forEach((table, idx) => {
                    const courtPlayers = idx === 0 ? aPlayers : bPlayers;
                    const wins = idx === 0 ? aCourtWins : bCourtWins;
                    courtPlayers.forEach(p => wins[p] = 0);
                    table.querySelectorAll('tbody tr').forEach(row => {
                        const p1 = row.querySelector('.player1').value.trim().replace(/\*/g, '');
                        const p2 = row.querySelector('.player2').value.trim().replace(/\*/g, '');
                        const p3 = row.querySelector('.player3').value.trim().replace(/\*/g, '');
                        const p4 = row.querySelector('.player4').value.trim().replace(/\*/g, '');
                        const score = row.querySelector('.score').value.trim();
                        if (p1 && p2 && p3 && p4 && /^\d+-\d+$/.test(score)) {
                            const [score1, score2] = score.split('-').map(Number);
                            if (score1 > score2) {
                                wins[p1]++;
                                wins[p2]++;
                            } else {
                                wins[p3]++;
                                wins[p4]++;
                            }
                        }
                    });
                });

                const { finalA, finalB } = generateFinalMatches(aPlayers, bPlayers, aCourtWins, bCourtWins);
                const finalATable = document.querySelector(`.schedule-table.final-a[data-round-id="${roundId}"]`);
                const finalBTable = document.querySelector(`.schedule-table.final-b[data-round-id="${roundId}"]`);
                
                const finalARow = finalATable.querySelector('tbody tr');
                finalARow.querySelector('.player1').value = finalA[0] || '';
                finalARow.querySelector('.player2').value = finalA[1] || '';
                finalARow.querySelector('.player3').value = finalA[2] || '';
                finalARow.querySelector('.player4').value = finalA[3] || '';

                const finalBRow = finalBTable.querySelector('tbody tr');
                finalBRow.querySelector('.player1').value = finalB[0] || '';
                finalBRow.querySelector('.player2').value = finalB[1] || '';
                finalBRow.querySelector('.player3').value = finalB[2] || '';
                finalBRow.querySelector('.player4').value = finalB[3] || '';

                showToast('결승 경기 배치 완료!');
            });
        });
    }

    document.addEventListener('DOMContentLoaded', () => {
        console.log("DOMContentLoaded 이벤트 실행");
        waitForElements('#schedule-container, #ranking-table tbody', () => {
            applyTheme(localStorage.getItem('theme') || 'dark');
            createScheduleRounds();
            createRankingRows();
            if (db) {
                loadData();
            } else {
                console.warn("DB 연결 없음!");
                showToast("DB 연결 실패!");
            }
            setupInputListeners();
            const themeToggle = document.getElementById('theme-toggle');
            if (themeToggle) {
                themeToggle.addEventListener('click', () => applyTheme(document.documentElement.getAttribute('data-theme') === 'dark' ? 'light' : 'dark'));
            }
            const kakaoShareBtn = document.getElementById('kakao-share-btn');
            if (kakaoShareBtn) {
                kakaoShareBtn.addEventListener('click', shareOnKakao);
            }
            const downloadCsvBtn = document.getElementById('download-csv');
            if (downloadCsvBtn) {
                downloadCsvBtn.addEventListener('click', downloadCSV);
            }
            console.log("이벤트 리스너 설정 완료!");
        });
    });
</script>
</body>
</html>